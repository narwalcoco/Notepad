<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="icon" href="google_keep.png" type="image/x-icon">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Notes</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <header>
    <h1>My Saved Notes</h1>
  </header>

  <main class="notes-grid" id="notesGrid"></main>

  <div class="buttons">
    <button id="backBtn">Back to Editor</button>
  </div>

  <script>
    const grid = document.getElementById('notesGrid');
    const backBtn = document.getElementById('backBtn');

    function renderMarkdown(md) {
      return md
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/gim, '<em>$1</em>')
        .replace(/`([^`]+)`/gim, '<code>$1</code>')
        .replace(/\n/g, '<br>');
    }

    /* ---------- LOAD NOTES ---------- */
    function loadNotes() {
      const notes = JSON.parse(localStorage.getItem('notes') || "[]");
      grid.innerHTML = '';
      if (!notes.length) {
        // Reset grid styles so the message centers correctly
        grid.style.display = 'block';
        grid.style.gridTemplateColumns = '';
        grid.style.gap = '';
        grid.style.justifyItems = '';

        grid.innerHTML = "<p style='text-align:center;'>No saved notes found.</p>";
        return;
      }

      // Make the grid auto-wrap after 3 cards
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(280px, 1fr))';
      grid.style.gap = '15px';
      grid.style.justifyItems = 'center';

      // Sort newest first
      notes.sort((a, b) => (b.updated || 0) - (a.updated || 0));

      notes.forEach(note => {
        const div = document.createElement('div');
        div.className = 'note-card';
        div.style.width = '260px';
        div.style.wordWrap = 'break-word';
        let lineCount = 0;
        let previewLines = [];
        (note.content || '').split('\n').some(line => {
          previewLines.push(line);
          lineCount++;
          return lineCount >= 10;
        });
        const renderedPreview = renderMarkdown(previewLines.join('\n'));
        const when = note.updated ? new Date(note.updated).toLocaleString() : 'Unknown';
        div.innerHTML = `
        <h3>${note.title || "(Untitled)"}</h3>
        <div class="markdown-preview">${renderedPreview}</div>
        <small>Last saved: ${when}</small>
        <div class="note-actions">
          <button class="edit-btn" data-id="${note.id}">Edit</button>
          <button class="del-btn" data-id="${note.id}">Delete</button>
        </div>
      `;
        grid.appendChild(div);
      });

      grid.querySelectorAll('.edit-btn').forEach(b => {
        b.addEventListener('click', (e) => {
          const id = Number(e.currentTarget.dataset.id);
          editNote(id);
        });
      });
      grid.querySelectorAll('.del-btn').forEach(b => {
        b.addEventListener('click', (e) => {
          const id = Number(e.currentTarget.dataset.id);
          deleteNote(id);
        });
      });
    }

    function editNote(id) {
      const notes = JSON.parse(localStorage.getItem('notes') || "[]");
      const note = notes.find(n => n.id === id);
      if (!note) return alert('Note not found');
      localStorage.setItem('editingNote', JSON.stringify(note));
      window.location.href = 'index.html';
    }

    function deleteNote(id) {
      if (!confirm("Delete this note? This action cannot be undone.")) return;
      let notes = JSON.parse(localStorage.getItem('notes') || "[]");
      notes = notes.filter(n => n.id !== id);
      localStorage.setItem('notes', JSON.stringify(notes));
      loadNotes();
    }

    backBtn.addEventListener('click', () => window.location.href = 'index.html');

    loadNotes();

    /* ---------- SECRET DELETE ALL (Shift + "delete all") ---------- */
    let secretBuffer = "";
    let secretTimer = null;
    const SECRET_PHRASE = "delete all";

    function resetSecretBuffer() {
      secretBuffer = "";
      if (secretTimer) { clearTimeout(secretTimer); secretTimer = null; }
    }

    function startSecretTimer() {
      if (secretTimer) clearTimeout(secretTimer);
      secretTimer = setTimeout(() => resetSecretBuffer(), 5000);
    }

    document.addEventListener('click', (ev) => {
      const tag = (ev.target && ev.target.tagName) ? ev.target.tagName.toLowerCase() : '';
      const isInteractive = ['input', 'textarea', 'select', 'button', 'a'].includes(tag) || ev.target.isContentEditable;
      if (!isInteractive) {
        resetSecretBuffer();
        startSecretTimer();
      } else {
        resetSecretBuffer();
      }
    });

    document.addEventListener('keydown', (ev) => {
      const active = document.activeElement;
      const activeTag = active && active.tagName ? active.tagName.toLowerCase() : '';
      const isEditing = activeTag === 'input' || activeTag === 'textarea' || active.isContentEditable;
      if (isEditing) return;
      if (!ev.shiftKey) return;

      if (ev.key.length === 1) {
        secretBuffer += ev.key.toLowerCase();
        startSecretTimer();
      } else if (ev.key === 'Backspace') {
        secretBuffer = secretBuffer.slice(0, -1);
        startSecretTimer();
      } else if (ev.key === 'Escape') {
        resetSecretBuffer();
        return;
      } else {
        return;
      }

      if (secretBuffer.endsWith(SECRET_PHRASE)) {
        resetSecretBuffer();
        if (confirm('Delete ALL app data (notes and editing state) from this browser? This cannot be undone.')) {
          localStorage.removeItem('notes');
          localStorage.removeItem('editingNote');
          alert('All notes deleted from localStorage.');
          location.reload();
        }
      }
    });
  </script>
</body>

</html>